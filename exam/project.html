<!DOCTYPE html>
<html><body>
        <div style="display: flex;">
            <div style="width: 600px">
                <canvas id="c" width="600px" height="300px"></canvas>
            </div>
        </div>
        <div>
            Noise:
            <input type="range" min="0" step="0.5" max="10" value="4" id="noise">
            Smooth:
            <input type="range" min="0.0" step="0.05" max="1.0" value="1.0" id="smoothness">
        </div>
        <div>
            Rotation:
            <input type="range" min="1" step="10" value="0" max="360" value="51" id="rotation">
            Rotate <input type="checkbox" id="rotate" checked>
        </div>
        <script id="vertex-shader-terrain" type="x-shader/x-vertex">
        const float lacunarity = 2.0;
        const int octaves = 7;
         
        float permute(float x) { return mod(34.0*x*x + x, 289.0); }

        float get_index(vec3 pi) { return permute(pi.x + permute(pi.y + permute(pi.z))); }
        
        vec3 pweights(vec3 t) { return t*t*t*(t*(t*6.0 - 15.0) + 10.0); }

        vec3 gradient(float idx)
        {
          float i = mod(idx, 12.0);
          i = i < 0.0 ? i + 12.0 : i;
          vec2 bits = mod(vec2(i, floor(i*0.5)), 2.0);
          vec2 signs = mix(vec2(1.0), vec2(-1.0), step(0.5, bits));
          vec3 G;
          G.x = i < 7.5 ? signs.x : 0.0;
          G.y = i < 3.5 ? signs.y : (i > 7.5 ? signs.x : 0.0);
          G.z = i > 3.5 ? signs.y : 0.0;
          return G;
        }

        float pnoise(vec3 p)
        {
          vec3 pi0 = floor(p);
          vec3 uvw = p - pi0;
          vec3 weights = pweights(uvw);

          float noise_sum = 0.0;
          for(float i = 0.0; i < 7.5; ++i)
          {
            vec3 corner = mod(vec3(i, floor(i*0.5), floor(i*0.25)), 2.0);
            vec3 pi = pi0 + corner;
            vec3 w = mix(1.0 - weights, weights, step(0.5, corner));
            float d = dot(uvw - corner, gradient(get_index(pi)));
            noise_sum += w.x*w.y*w.z*d;
          }
          return noise_sum;
        }
        float pnoisenorm(vec3 point)
        {
            return pnoise(point) * 0.5 + 0.5; 
        }
        float fbm(vec3 point, float H)
        {
            float result = 0.0;
            float max = 0.0;
            for(int i=0;i<octaves;++i)
            {
                float dampen = pow(lacunarity, -H * float(i));
                result += pnoisenorm(point) * dampen;
                max += 1.0 * dampen;
                point *= lacunarity;
            }
            return  result / max;
        }

        attribute vec4 a_Position;


        uniform float scale;
        uniform float H;
        uniform mat4 P;
        uniform mat4 MV;
        uniform mat3 normMatrix;
        uniform mat4 lightMVP;
        uniform mat3 shadowMV;

        varying float height;
        varying float heightNoise;
        varying vec2 uv;
        varying vec4 lightPerspectivePosition;
        // For diffuse shading
        varying vec3 normal;
        varying vec3 eyeDir;
         
        vec3 estimateNormal(vec3 position)
        {
            return normalize(vec3(fbm(scale * vec3(position.x - 0.01, position.yz), H) - fbm(scale * vec3(position.x + 0.01, position.yz), H), 
                    fbm(scale * vec3(position.x, position.y - 0.01, position.z), H) - fbm(scale * vec3(position.x, position.y + 0.01, position.z), H), 
                    2.0 * position.z)); 
        }

        void main()
        {
            const bool use_fbm = true;
            float delta = use_fbm ? fbm(scale * a_Position.xyz, H) : pnoisenorm(scale * vec3(a_Position.xyz));
            height = delta;
            heightNoise = pnoisenorm(20.0 * a_Position.xyz) * 0.05;
            vec4 transformedPosition = vec4(a_Position.xy, delta, 1);
            lightPerspectivePosition = lightMVP * transformedPosition;
            gl_Position = P * MV * transformedPosition;
            uv = a_Position.xy;

            normal = estimateNormal(a_Position.xyz);
            eyeDir = -normalize((MV * transformedPosition).xyz);
        }
        </script>
        <script id="fragment-shader-terrain" type="x-shader/x-fragment">
            precision mediump float;
            const vec3 snow = vec3(203, 214, 206)/255.0;        
            const vec3 ground = vec3(80, 53, 37)/255.0;
            const vec3 grass = vec3(56, 112, 0)/255.0;

            uniform sampler2D shadowMap;
            float unpackDepth(const in vec4 rgbaDepth) {   
            const vec4 bitShift = vec4(1.0, 1.0/256.0, 
                                       1.0/(256.0*256.0), 
                                       1.0/(256.0*256.0*256.0));   
            return dot(rgbaDepth, bitShift); 
            } 
            varying float height;
            varying float heightNoise;
            varying vec2 uv;
            varying vec4 lightPerspectivePosition;
            // Diffuse shading
            varying vec3 normal;
            varying vec3 eyeDir;
            uniform vec3 lightPosition;
            const vec2 texmapScale = vec2(1.0 / 512.0, 1.0 / 512.0);

            float offset_lookup(vec3 shadowCoord, vec2 offset)
            {
                return unpackDepth(texture2D(shadowMap, shadowCoord.xy + offset * texmapScale));
            }
        

            void main()
            {
                vec3 color;
                if((height + abs(heightNoise)) > 0.66)
                    color = snow;
                else if(height - abs(heightNoise) * 0.1  > 0.45)
                    color = ground; 
                else 
                    color = grass;

                vec3 lightNDC = 0.5 * (lightPerspectivePosition.xyz / lightPerspectivePosition.w) + 0.5;
                float sum = 0.0;
                for(float y=-1.5;y<=1.5;y+=1.0)
                {
                    for(float x=-1.5;x<=1.5;x+=1.0)
                    {
                        sum += offset_lookup(lightNDC, vec2(x, y));
                    }
                }

                float shadowDepth = sum / 16.0;
                //shadowDepth = unpackDepth(texture2D(shadowMap, lightNDC.xy));
                float shaderContrib = 1.0;
                if(shadowDepth + 0.0010 < lightNDC.z)
                    shaderContrib = 0.2;
                

                // Diffuse
                float diffuseFactor = max(dot(normalize(lightPosition), normalize(normal)), 0.0); 
                float t = dot(normalize(lightPosition), normalize(normal));
                vec3 diffuse = color * diffuseFactor;
                vec3 ambient = color * 0.8;
                gl_FragColor = vec4((diffuse + ambient)  * shaderContrib, 1); 
             }
        </script>
        <script id="vertex-shader-shadowmap" type="x-shader/x-fragment">
        const float lacunarity = 2.0;
        const int octaves = 7;
         
        float permute(float x) { return mod(34.0*x*x + x, 289.0); }

        float get_index(vec3 pi) { return permute(pi.x + permute(pi.y + permute(pi.z))); }
        
        vec3 pweights(vec3 t) { return t*t*t*(t*(t*6.0 - 15.0) + 10.0); }

        vec3 gradient(float idx)
        {
          float i = mod(idx, 12.0);
          i = i < 0.0 ? i + 12.0 : i;
          vec2 bits = mod(vec2(i, floor(i*0.5)), 2.0);
          vec2 signs = mix(vec2(1.0), vec2(-1.0), step(0.5, bits));
          vec3 G;
          G.x = i < 7.5 ? signs.x : 0.0;
          G.y = i < 3.5 ? signs.y : (i > 7.5 ? signs.x : 0.0);
          G.z = i > 3.5 ? signs.y : 0.0;
          return G;
        }

        float pnoise(vec3 p)
        {
          vec3 pi0 = floor(p);
          vec3 uvw = p - pi0;
          vec3 weights = pweights(uvw);

          float noise_sum = 0.0;
          for(float i = 0.0; i < 7.5; ++i)
          {
            vec3 corner = mod(vec3(i, floor(i*0.5), floor(i*0.25)), 2.0);
            vec3 pi = pi0 + corner;
            vec3 w = mix(1.0 - weights, weights, step(0.5, corner));
            float d = dot(uvw - corner, gradient(get_index(pi)));
            noise_sum += w.x*w.y*w.z*d;
          }
          return noise_sum;
        }
        float pnoisenorm(vec3 point)
        {
            return pnoise(point) * 0.5 + 0.5; 
        }
        float fbm(vec3 point, float H)
        {
            float result = 0.0;
            float max = 0.0;
            for(int i=0;i<octaves;++i)
            {
                float dampen = pow(lacunarity, -H * float(i));
                result += pnoisenorm(point) * dampen;
                max += 1.0 * dampen;
                point *= lacunarity;
            }
            return  result / max;
        }

        attribute vec4 a_Position;
        uniform float scale;
        uniform float H;
        uniform mat4 P;
        uniform mat4 MV;
        varying float height;
        varying vec2 uv;
        void main()
        {
            const bool use_fbm = true;
            float delta = use_fbm ? fbm(scale * a_Position.xyz, H) : pnoisenorm(scale * vec3(a_Position.xyz));
            height = delta;
            vec4 transformedPosition = vec4(a_Position.xy, delta, 1);
            gl_Position = P * MV * transformedPosition;
            uv = a_Position.xy;
        }
        </script>
        <script id="fragment-shader-shadowmap" type="x-shader/x-fragment">
            precision mediump float;
            varying float height;
            varying vec2 uv;
            void main()
            {
                const vec4 bitShift = vec4(1.0, 256.0, 256.0*256.0, 256.0*256.0*256.0); 
                const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0);
                vec4 rgbaDepth = fract(gl_FragCoord.z*bitShift);
                rgbaDepth -= rgbaDepth.gbaa*bitMask;
                gl_FragColor = rgbaDepth;//vec4(gl_FragCoord.z, 0, 0, 1.0);
            }
        </script>
        <script type="text/javascript" src="Light.js"></script>
        <script type="text/javascript" src="../lib/angel/initShaders.js"></script>
        <script type="text/javascript" src="Primitives.js"></script>
        <script type="text/javascript" src="DrawArray.js"></script>
        <script type="text/javascript" src="../lib/angel/MV.js"></script>
        <script type="text/javascript" src="OBJParser.js"></script>
        <script type="text/javascript" src="../lib/angel/webgl-utils.js"></script>
        <script type="text/javascript" src="GLBuffer.js"></script>
        <script type="text/javascript" src="project.js"></script>
</body></html>
