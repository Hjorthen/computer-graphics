<!DOCTYPE html>
<html><body>
        <div style="display: flex;">
            <div style="width: 600px">
                <canvas id="c" width="600px" height="200px"></canvas>
            </div>
        </div>
        <div>
            Noise:
            <input type="range" min="0" step="0.5" max="10" id="noise">
            Smooth:
            <input type="range" min="0.0" step="0.05" max="1.0" id="smoothness">
            Height:
            <input type="range" min="1" step="10" value="0" max="360" id="height">
        </div>
        <script id="vertex-shader-terrain" type="x-shader/x-vertex">
        const float lacunarity = 2.0;
        const int octaves = 8;
         
        float permute(float x) { return mod(34.0*x*x + x, 289.0); }

        float get_index(vec3 pi) { return permute(pi.x + permute(pi.y + permute(pi.z))); }
        
        vec3 pweights(vec3 t) { return t*t*t*(t*(t*6.0 - 15.0) + 10.0); }

        vec3 gradient(float idx)
        {
          float i = mod(idx, 12.0);
          i = i < 0.0 ? i + 12.0 : i;
          vec2 bits = mod(vec2(i, floor(i*0.5)), 2.0);
          vec2 signs = mix(vec2(1.0), vec2(-1.0), step(0.5, bits));
          vec3 G;
          G.x = i < 7.5 ? signs.x : 0.0;
          G.y = i < 3.5 ? signs.y : (i > 7.5 ? signs.x : 0.0);
          G.z = i > 3.5 ? signs.y : 0.0;
          return G;
        }

        float pnoise(vec3 p)
        {
          vec3 pi0 = floor(p);
          vec3 uvw = p - pi0;
          vec3 weights = pweights(uvw);

          float noise_sum = 0.0;
          for(float i = 0.0; i < 7.5; ++i)
          {
            vec3 corner = mod(vec3(i, floor(i*0.5), floor(i*0.25)), 2.0);
            vec3 pi = pi0 + corner;
            vec3 w = mix(1.0 - weights, weights, step(0.5, corner));
            float d = dot(uvw - corner, gradient(get_index(pi)));
            noise_sum += w.x*w.y*w.z*d;
          }
          return noise_sum;
        }
        float pnoisenorm(vec3 point)
        {
            return pnoise(point) * 0.5 + 0.5; 
        }
        float fbm(vec3 point, float H)
        {
            float result = 0.0;
            float max = 0.0;
            for(int i=0;i<octaves;++i)
            {
                float dampen = pow(lacunarity, -H * float(i));
                result += pnoisenorm(point) * dampen;
                max += 1.0 * dampen;
                point *= lacunarity;
            }
            return  result / max;
        }

        attribute vec4 a_Position;


        uniform float scale;
        uniform float H;
        uniform mat4 P;
        uniform mat4 MV;
        uniform mat4 lightMVP;
        varying float height;
        varying vec2 uv;
        varying vec4 lightPerspectivePosition;
        void main()
        {
            const bool use_fbm = true;
            float delta = use_fbm ? fbm(scale * a_Position.xyz, H) : pnoisenorm(scale * vec3(a_Position.xyz));
            height = delta;
            vec4 transformedPosition = vec4(a_Position.xy, delta, 1);
            lightPerspectivePosition = lightMVP * transformedPosition;
            gl_Position = P * MV * transformedPosition;
            uv = a_Position.xy;
        }
        </script>
        <script id="fragment-shader-terrain" type="x-shader/x-fragment">
            precision mediump float;
            const vec3 snow = vec3(203, 214, 206)/255.0;        
            const vec3 ground = vec3(89, 52, 27)/255.0;
            const vec3 grass = vec3(56, 112, 0)/255.0;
         

            uniform sampler2D shadowMap;
             
            varying float height;
            varying vec2 uv;
            varying vec4 lightPerspectivePosition;
            void main()
            {
                vec3 color;
                if(height > 0.66)
                    color = snow;
                else if(height > 0.5)
                    color = ground; 
                else 
                    color = grass;

                vec3 lightNDC = 0.5 * (lightPerspectivePosition.xyz / lightPerspectivePosition.w) + 0.5;
                float shadowDepth = texture2D(shadowMap, lightNDC.xy).r;
                float shaderContrib = 1.0;
                if(shadowDepth + 0.002 < lightNDC.z)
                    shaderContrib = 0.2;
                gl_FragColor = vec4(color * shaderContrib, 1);
            }
        </script>
        <script id="vertex-shader-shadowmap" type="x-shader/x-fragment">
        const float lacunarity = 2.0;
        const int octaves = 8;
         
        float permute(float x) { return mod(34.0*x*x + x, 289.0); }

        float get_index(vec3 pi) { return permute(pi.x + permute(pi.y + permute(pi.z))); }
        
        vec3 pweights(vec3 t) { return t*t*t*(t*(t*6.0 - 15.0) + 10.0); }

        vec3 gradient(float idx)
        {
          float i = mod(idx, 12.0);
          i = i < 0.0 ? i + 12.0 : i;
          vec2 bits = mod(vec2(i, floor(i*0.5)), 2.0);
          vec2 signs = mix(vec2(1.0), vec2(-1.0), step(0.5, bits));
          vec3 G;
          G.x = i < 7.5 ? signs.x : 0.0;
          G.y = i < 3.5 ? signs.y : (i > 7.5 ? signs.x : 0.0);
          G.z = i > 3.5 ? signs.y : 0.0;
          return G;
        }

        float pnoise(vec3 p)
        {
          vec3 pi0 = floor(p);
          vec3 uvw = p - pi0;
          vec3 weights = pweights(uvw);

          float noise_sum = 0.0;
          for(float i = 0.0; i < 7.5; ++i)
          {
            vec3 corner = mod(vec3(i, floor(i*0.5), floor(i*0.25)), 2.0);
            vec3 pi = pi0 + corner;
            vec3 w = mix(1.0 - weights, weights, step(0.5, corner));
            float d = dot(uvw - corner, gradient(get_index(pi)));
            noise_sum += w.x*w.y*w.z*d;
          }
          return noise_sum;
        }
        float pnoisenorm(vec3 point)
        {
            return pnoise(point) * 0.5 + 0.5; 
        }
        float fbm(vec3 point, float H)
        {
            float result = 0.0;
            float max = 0.0;
            for(int i=0;i<octaves;++i)
            {
                float dampen = pow(lacunarity, -H * float(i));
                result += pnoisenorm(point) * dampen;
                max += 1.0 * dampen;
                point *= lacunarity;
            }
            return  result / max;
        }

        attribute vec4 a_Position;
        uniform float scale;
        uniform float H;
        uniform mat4 P;
        uniform mat4 MV;
        varying float height;
        varying vec2 uv;
        void main()
        {
            const bool use_fbm = true;
            float delta = use_fbm ? fbm(scale * a_Position.xyz, H) : pnoisenorm(scale * vec3(a_Position.xyz));
            height = delta;
            vec4 transformedPosition = vec4(a_Position.xy, delta, 1);
            gl_Position = P * MV * transformedPosition;
            uv = a_Position.xy;
        }
        </script>
        <script id="fragment-shader-shadowmap" type="x-shader/x-fragment">
            precision mediump float;
            varying float height;
            varying vec2 uv;
            void main()
            {
                gl_FragColor = vec4(gl_FragCoord.z, 0, 0, 1.0);
            }
        </script>
        <script type="text/javascript" src="Light.js"></script>
        <script type="text/javascript" src="../lib/angel/initShaders.js"></script>
        <script type="text/javascript" src="Primitives.js"></script>
        <script type="text/javascript" src="DrawArray.js"></script>
        <script type="text/javascript" src="../lib/angel/MV.js"></script>
        <script type="text/javascript" src="OBJParser.js"></script>
        <script type="text/javascript" src="../lib/angel/webgl-utils.js"></script>
        <script type="text/javascript" src="GLBuffer.js"></script>
        <script type="text/javascript" src="project.js"></script>
</body></html>
